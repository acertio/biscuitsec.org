# Example : rental car agency management
One of the ideas that we can illutrate with biscuit tokens is the management  of the access of a rental agency cars.
So we will represent some explained tokens giving the rental agency and its client specific rights.

## The first token : all rights token
The token below gives the rental agency the right to do any operation on any resource which is logic beacause the rental agency is the owner of all the resources ( the cars ).
```
Biscuit {
    symbols: ["authority", "ambient", "resource", "operation", "right", "current_time", "revocation_id", "open", "owner", "caveat1", "caveat2", "alice"]
    authority: Block[0] {
            symbols: []
            context: ""
            facts: [
		
	           ]

            rules: [
                right(#Authority, 0?, 1?) <- resource(#ambient, 0?) && operation(#ambient,1?) | 
            ]
            caveats: []
        }
    blocks: [
       
    ]
}
```
## Attenuation token : 
In order to rent its cars the rental agency must give the clients access to those cars. Nomally the agency gives its clients the physical keys, but nowadays a mobile application is much more modern ;-) A real example has been demonstrated by BMW.  

In our example we assume we use a mobileapp to handle the rights via a biscuit token.

The initial token is generated by the agency, which defines special rights for its employees. Then before delivering the keys to a customer, the agency attenuates the token.

Below you will find some examples of token attenuation :

## Token giving a client named Alice the right  to do any operation only on a specific car

For every attenuation a new block is added to the token , in the exemple below the new added block is block[1]
```

 Biscuit {
    symbols: ["authority", "ambient", "resource", "operation", "right", "current_time", "revocation_id", "caveat1", "caveat2", "driver", "alice"]
    authority: Block[0] {
            symbols: []
            context: ""
            facts: []
            rules: [
                *right(#authority, $0, $1) <- !resource(#ambient, $0), !operation(#ambient, $1)
            ]
            caveats: []
        }
    blocks: [
        Block[1] {
            symbols: ["caveat1", "caveat2", "driver", "alice"]
            context: ""
            facts: []
            rules: []
            caveats: [
                *caveat1($0, $1) <- !right(#authority, $0, $1), !resource(#ambient, $0), !operation(#ambient, $1),
                *caveat2($0) <- !resource(#ambient, $0), !driver(#ambient, #alice, $0) @ $0 in {"car1"}
            ]
        }
    ]
}
```
How the token will be verified by the car ? 

we assume that the every car is identied by unique id (car1 in our exemple), we assume also that the has an authentification protocol to know the identity of the driver.

after the authentification the driver requests an operation (drive for exemple), so the car creates a verifier and adds the ambient data, in our case the car identifier (car1 ), the operation that the client has requested and an ambient fact indicating the identity of the driver and the operation that he wants to do (driver(#ambient, #alice, drive).

If the identity of the driver is alice and the car name is car1, then the verification will succeed and the car will be turned on.

## Token giving a person named Alice the right  to open a specific car
In this example we will assume that Alice is in a showroom, with the right to open the car doors and chest.
```


Biscuit {
    symbols: ["authority", "ambient", "resource", "operation", "right", "current_time", "revocation_id", "caveat1", "caveat2", "driver", "alice"]
    authority: Block[0] {
            symbols: []
            context: ""
            facts: []
            rules: [
                *right(#authority, $0, $1) <- !resource(#ambient, $0), !operation(#ambient, $1)
            ]
            caveats: []
        }
    blocks: [
        Block[1] {
            symbols: ["caveat1", "caveat2", "driver", "alice"]
            context: ""
            facts: []
            rules: []
            caveats: [
                *caveat1($0, $1) <- !right(#authority, $0, $1), !resource(#ambient, $0), !operation(#ambient, $1) @ 1$ in{"open_door","open_chest"}
                *caveat2($0) <- !resource(#ambient, $0), !driver(#ambient, #alice, $0) @ $0 in {"car1"}
            ]
        }
    ]
}

```
## Token giving a person named Alice the right  to open and drive a specific car for a limited period (one week) 
A restriction on time can be set to the token, so after a specific period the token will no longer turn on or open the car.

In the example below the rental agency will rent the car to Alice for one week so the token will not work after a week (here specified as an absolute date).
```
Biscuit {
    symbols: ["authority", "ambient", "resource", "operation", "right", "current_time", "revocation_id", "caveat1", "caveat2", "owner", "alice", "expiration_check", "time"]
    authority: Block[0] {
            symbols: []
            context: ""
            facts: []
            rules: [
                *right(#authority, $0, $1) <- !resource(#ambient, $0), !operation(#ambient, $1)
            ]
            caveats: []
        }
    blocks: [
        Block[1] {
            symbols: ["caveat1", "caveat2", "driver", "alice", "expiration_check", "time"]
            context: ""
            facts: []
            rules: []
            caveats: [
							  *caveat1($0, $1) <- !right(#authority, $0, $1), !resource(#ambient, $0), !operation(#ambient, $1) @ 1$ in{"open_door","open_chest","drive"}
                *caveat2($0) <- !resource(#ambient, $0), !driver(#ambient, #alice, $0) @ $0 in {"car1"}
								*expiration_check($2) <- !time(#ambient, $2) @ $2 <= 2020-07-01T12:35:10+00:00
            ]
        }
    ]
}
```
## The rental agency can revocate the token
the rental agency has the possibility to revocate and make a token unusable using a revocation id 
```
Biscuit {
    symbols: ["authority", "ambient", "resource", "operation", "right", "current_time", "revocation_id", "caveat1", "caveat2", "owner", "alice", "expiration_check", "time"]
    authority: Block[0] {
            symbols: []
            context: ""
            facts: []
            rules: [
                *right(#authority, $0, $1) <- !resource(#ambient, $0), !operation(#ambient, $1)
            ]
            caveats: []
        }
    blocks: [
        Block[1] {
            symbols: ["caveat1", "caveat2", "driver", "alice", "expiration_check", "time"]
            context: ""
            facts: [
								revocation_id("12345678")
									  ]
            rules: []
            caveats: [
							  *caveat1($0, $1) <- !right(#authority, $0, $1), !resource(#ambient, $0), !operation(#ambient, $1) @ 1$ in{"open_door","open_chest","drive"}
                *caveat2($0) <- !resource(#ambient, $0), !driver(#ambient, #alice, $0) @ $0 in {"car1"}
								*expiration_check($2) <- !time(#ambient, $2) @ $2 <= 2020-07-01T12:35:10+00:00
            ]
        }
    ]
}
```
In the verifier the rental agency can add this rule to verify the revocation :

- revocation_check(0?) <- revocation_id(0?) | 0? not in {1 , 12345678, 2, 5, 0}

The verification of the token above will fail because the verification_id is in the list {1 , 12345678, 2, 5, 0}
